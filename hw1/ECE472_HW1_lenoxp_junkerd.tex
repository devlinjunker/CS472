\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Philip Lenox, Devlin Junker}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 1''},
  pdftitle = {CS 472: Homework 1},
  pdfsubject = {CS 472: Homework 1},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 HW 1

\begin{enumerate}



\item[$(1.3)$] We said that the pattern of $1$s and $0$s used to represent an instruction
  in a computer has no intrinsic meaning. Why is this so and what is the implication of
  this statement?

  The pattern of $1$s and $0$s has no intrinsic meaning because us, as programmers and CPU
  designers, decide what instructions the computer will perform based on a given pattern. The
  implication of this, is that we can create and model anything that can be represented
  quantitatively.
  
\item[$(1.5)$] Modify the algorithm used in this chapter to locate the longest run of
  non-consecutive characters in the string.

    \begin{enumerate}
        \item[$1.$] Read the first digit in the string and call it new\_digit
        \item[$2.$] Set the current\_run\_value to new\_digit
        \item[$3.$] Set the current\_run\_length to 1
        \item[$4.$] Set the max\_run to 1
        \item[$5.$] REPEAT
        \item[$6.$] Read the next digit in the sequence (i.e. read new\_digit)
        \item[$7.$] IF its value is not the same as current\_run\_value
        \item[$8.$] THEN {current\_run\_length = current\_run\_length +1
                          current\_run\_value = new\_digit}
        \item[$10.$] ELSE current\_run\_length = 1
        \item[$11.$] IF current\_run\_length > max\_run
        \item[$12.$] THEN max\_run = current\_run\_length
        \item[$13.$] UNTIL The last digit is read
    \end{enumerate}

  

\item[$(1.8)$] What are the differences between RTL, machine language, assembly language,
  high-level language, and pseudocode?
  
	RTL, or register transfer language, is a way of symbolically representing operation in a computer
	in a specific way to make clear memory accesses, data movement. 
	
	Machine language is the binary sequence that is fetched and executed by the processor. This is
	the lowest level a computer program is converted to.
	
	Assembly language is the symbolic representation of machine code that make it human readable. 
	Opcodes are replaced by a string of characters representing the operation, and memory location may
	be refered to symbolically rather than directly. Assembly code must be assembled to be converted to
	machine code.
	
	High-level language refers to any programming language that is higher level than assembly. Patterns of assembly
	are refered to in a form more easily human readable. This includes easier to read conditional statements,
	pre-defined data types, and more sophisticated operation not supported intrinsically by the hardware. High level
	languages must be compiled in order to be converted to machine language.
	
	Psuedocode consists of the highest level ideas of a program's structure. This "code" cannot be converted to 
	machine code as it does not follow a specific syntax, and may leave many of the details of the implementation
	of the code out. It is useful to write psuecode as an outline for the actual code. 

\item[$(1.12)$]What is the difference between a computer's \textit{architecture} and its
  \textit{organization}?
  
  A computer's \textit{architecture} refers to the ISA, the part of the computer visible to the computer's 
  programmer. Architecture is conserned only with the outward appearance of the computer, and not with how it
  is implemented in hardware. The instructions that a computer can execute and the data those instructions can be
  executed on make up the computer architecture.
  
  A computer \textit{organization} refers to the hardware implementation of the architecture. The organization is concerned with the size of data buses, registers, pipelines, data and control hazards, etc.
\item[$(1.18)$]What is the von Neumann bottleneck?

The von Neumann bottleneck refers to the limitation of a computer's processor to access memory due to the disparity in speed between the CPU and memory. As the processor increases in speed, the bottleneck becomes accessing the data stored in the memory. 

\item[$(1.33)$]Is Moore's law a law?

Moore's law is not really a law, as it is not a statement that can be rigorously tested through repeated experiments.  Moore's law is more of an observation about trends in computing technology.

\end{enumerate}



\end{document}
