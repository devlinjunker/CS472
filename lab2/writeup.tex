\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Philip Lenox, Devlin Junker}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' clements ``chapter 1''},
  pdftitle = {CS 472: Homework 2},
  pdfsubject = {CS 472: Homework 2},
  pdfpagemode = UseNone
}

\begin{document}
\hfill \name

\hfill \today

\hfill CS 472 Lab 2
\\
\\
Any optimization (1, 2, or 3) used the compiler to solve the problem because the string we were checking was hardcoded into the program. Because of this, the compiler could do the check itself and know that the answer would be the same every time, then remove all of the code that looped through the characters comparing them and simply stored the result in r0. The code that was produced in the default output (not-optimized), was much more complex than the assembly that I wrote for the homework assignment. The compiled (but not assembled) c program took up 67 lines (some of which were comments, so probably closer to 60), where as my assembly program that performed the same check used only 18 lines. The assember, when on O1, instead of creating a loop the way I did in the assignment, broke the loop into different sections, and then conditionally branches from each section to the next. This is known as unrolling or loop unwinding. Essentially the tradeoff being made is size of the code vs the speed of execution. Unrolling the loop into longer sections without a branch conditional, and using fewer branches will in general be faster. Since the value is known going into the program, the optimizations that follow identify that the output will always be the same, and just outputs that.




\end{document}
